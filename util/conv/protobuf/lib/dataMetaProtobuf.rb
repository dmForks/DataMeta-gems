$:.unshift(File.dirname(__FILE__)) unless $:.include?(File.dirname(__FILE__)) || $:.include?(File.expand_path(File.dirname(__FILE__)))

require 'erb'
require 'fileutils'
require 'dataMetaDom'
require 'dataMetaDom/help'
require 'dataMetaDom/pojo'
require 'dataMetaDom/record'
require 'dataMetaDom/util'
require 'ostruct'

=begin rdoc
DataMetaDOM and {Protobuf}[https://github.com/google/protobuf/wiki] {IDL}[https://developers.google.com/protocol-buffers/docs/proto].

For command line details either check the new method's source or the README, the usage section.
=end

module DataMetaProtobuf
    # Current version
    VERSION = '1.0.2'

# First level indent
    INDENT = ' ' * 4

    # Since we are piping source in and spilling the result into the STDOUT, need logger for any other output.
    L = Logger.new('dataMetaProtobuf.log', 0, 10_000_000)
    L.level = Logger::INFO
    L.datetime_format = '%Y-%m-%d %H:%M:%S'

    # The root of the gem.
    GEM_ROOT = File.realpath(File.dirname(__FILE__) + '/../')

    # Location of templates.
    TMPL_ROOT = File.join(GEM_ROOT, 'tmpl')

=begin rdoc
Mapping from a DataMeta DOM type to a matching renderer of Protobuf IDL.
=end
    PROTO_TYPES = {
            DataMetaDom::BOOL => lambda{|dt| %q<bool>},
            DataMetaDom::CHAR => lambda{|dt| %q<string>},
            DataMetaDom::INT => lambda{ |dt|
              len = dt.length
              case
                when len <= 4; %q<int32>
                when len <= 8; %q<int64>
                else; raise "Invalid integer length #{len}"
              end
            },
            DataMetaDom::FLOAT => lambda{|dt|
              len = dt.length
              case
                when len <= 4; %q<float>
                when len <= 8; %q<double>
                else; raise "Invalid float length #{len}"
              end
            },
            DataMetaDom::RAW => lambda{|dt| %q<bytes>},
            DataMetaDom::STRING => lambda{|dt| %q<string>},
=begin
Unlike DataMeta DOM, Protobuf does not support temporal types such as date, time and datetime, therefore we export
DataMeta +datetime+ as +string+.
=end
        DataMetaDom::DATETIME => lambda{|dt| %q<string>},
# No support for these in this release:
          #NUMERIC => lambda{|t| "BigDecimal"}
    }

=begin rdoc
Converts DataMeta DOM type to Protobuf IDL type.
=end
    def protoType(dataMetaType, model, rec)
        ty = dataMetaType.type
        if model.records[ty]
            nameSpace, base = assertNamespace(ty)
            base
        elsif model.enums[ty]
            nameSpace, base = assertNamespace(ty)
            base
        else
            renderer = PROTO_TYPES[dataMetaType.type]
            raise "Unsupported type #{dataMetaType}" unless renderer
            renderer.call(dataMetaType)
        end
    end

=begin rdoc
Splits the full name of a class into the namespace and the base, returns an array of
the namespace (empty string if there is no namespace on the name) and the base name.

Examples:
* <tt>'BaseNameAlone'</tt> -> <tt>['', 'BaseNameAlone']</tt>
* <tt>'one.package.another.pack.FinallyTheName'</tt> -> <tt>['one.package.another.pack', 'FinallyTheName']</tt>
=end
    def assertNamespace(fullName)
      ns, base = DataMetaDom::splitNameSpace(fullName)
      [DataMetaDom.validNs?(ns, base) ? ns : '', base]
    end

=begin rdoc
Generates the {Protobuf IDL}[https://developers.google.com/protocol-buffers/docs/proto], returns the source.

We decided against using the template and use simple string concatenation instead; because the way Protobuf IDL is
designed, it's easier to do the string concat. For example, rendering a message in a message in a message...
=end
    def genSchema(model)
        result = %<
// This Protobuf schema is generated by DataMeta exporter.

syntax = "proto3";
package #{model.sources[model.sources.doneKeys[0]].namespace};

>
        model.enums.values.each { |e| renderEnum model, e, result }
        model.records.values.each { |r| renderRec model, r, result }
        result << "\n"
        result
    end

# Render a single record
    def renderRec(model, rec, result)
        nameSpace, base = assertNamespace(rec.name)
        L.info("Rendering record #{rec.name}")
        result << %<
message #{base} {
>
        pbInt = 1
        rec.fields.each_key { | fldId|
            fld = rec.fields[fldId]
            ty = fld.dataType.type
            if fld.aggr && !fld.map?
                result << "#{INDENT}repeated #{protoType(fld.dataType, model, rec)} #{fldId} = #{pbInt};\n"
            elsif fld.map?
                raise ArgumentError, %<Field "#{fldId}" of the rec "#{base}": for Protobuf, map can not be optional, it must be required> unless fld.isRequired
                result << "#{INDENT}map<#{protoType(fld.dataType, model, rec)}, #{protoType(fld.trgType, model, rec)}> #{fldId} = #{pbInt};\n"
            elsif model.enums[ty] && model.enums[ty].is_a?(DataMetaDom::Mapping)
                raise ArgumentError, %<Field "#{fldId}" of the rec "#{base}": for Protobuf, map can not be optional, it must be required> unless fld.isRequired
                result << "#{INDENT}map<#{protoType(model.enums[ty].fromT, model, rec)}, #{protoType(model.enums[ty].toT, model, rec)}> #{fldId} = #{pbInt};\n"
            elsif fld.isRequired
                result << "#{INDENT}#{protoType(fld.dataType, model, rec)} #{fldId} = #{pbInt};\n"
            else
                result << "#{INDENT}repeated #{protoType(fld.dataType, model, rec)} #{fldId} = #{pbInt};\n"
            end
            pbInt += 1
        }
        result << %q<}
>
    end

# Render one single enum
    def renderEnum(model, enm, result)
        nameSpace, base = assertNamespace(enm.name)
        L.info("Rendering enum #{enm.name} of the type #{enm.class}")
        case enm
            when DataMetaDom::Enum
                values = enm.keys.map{|k| enm[k]} # sorted by ordinals to preserve the original order
                pbInt = 0
                result << %<
enum #{base} {
>
                values.each{|v|
                    result << "#{INDENT}#{v} = #{pbInt};\n"
                    pbInt += 1
                }
                result << %q<}
>
            when DataMetaDom::Mapping
                # taken care of in renderDer
            else
                raise ArgumentError, %<Unsupported enum type "#{enm.class}" for the name "#{enm.name}">

        end

    end

    # Shortcut to help for the Protobuf IDL generator
    def helpProtobufGen(file, errorText=nil)
        DataMetaDom::help(file, %<DataMeta DOM Protobuf IDL Generation ver #{VERSION}>, '<DataMeta DOM source file>', errorText)
    end

module_function :helpProtobufGen, :genSchema, :assertNamespace, :protoType, :renderRec, :renderEnum
end
