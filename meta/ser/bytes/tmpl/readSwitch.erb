<%#
    Template for Java migration guides
%>
package <%=javaPackage%>;
/*
           This class is generated by DataMeta DOM. Do not edit manually!
*/
import org.ebay.datameta.ser.bytes.InOutable;
import org.ebay.datameta.util.jdk.SemanticVersion;

import java.io.DataInput;
import java.io.IOException;

public class <%=javaClassName%> {

    private static final <%=javaClassName%> INSTANCE = new <%=javaClassName%>();

    public static <%=javaClassName%> getInstance() { return INSTANCE; }

<% model2.records.values.each { |trgE|
    vars.versCases = vers.clone.select{|v| v < ver2}.sort{|x, y| y<=>x}
    vars.javaPackage, vars.baseName, vars.packagePath = assertNamespace(trgE.name)
    srcRecName = flipVer(trgE.name, ver2.toVarName, ver1.toVarName)
    srcE = model1.records[srcRecName]
    if srcE
%>
    public <%= vars.baseName %> read_<%= vars.baseName %>_versioned(final DataInput in) throws IOException {
        final SemanticVersion ver = InOutable.readVersion(in);
        if(ver.equals(<%=vars.baseName%>.VERSION)) {
                return <%=vars.baseName%>_InOutable.getInstance().read(in);
<%
  while vars.versCases.length > 0 # loop through the case statement - a version per each
  vars.switchTargVer = vars.versCases.shift
  vars.brackets = ''
  caseObjName = flipVer(trgE.name, ver2.toVarName, vars.switchTargVer.toVarName)
  caseMod = modelForVer.call(vars.switchTargVer)
  next unless caseMod.records.keys.member?(caseObjName.to_sym) # skip cases for the versions where this object's target version does not exist
%>
       }
       else if(ver.equals(<%=caseObjName%>.VERSION)){<% vars.versMigr =  vers.clone.select{|v| v <= ver2}.sort{|x, y| y<=>x}%>
                return <%  while vars.versMigr.length > 0 # migration steps loop nested in the case statement loop
      vars.brackets << ')'
      vars.migrTargVer = vars.versMigr.shift # target version for migration loop
      vars.srcVer = vars.versMigr[0]
      vars.srcType = flipVer(trgE.name, ver2.toVarName, vars.srcVer.toVarName)
      migrMod = modelForVer.call(vars.srcVer)
      break unless migrMod.records.keys.member?(vars.srcType.to_sym) # enough if there is no record in the target version
      vars.jpMigr = vars.javaPackage.gsub(".v#{ver2.toVarName}", ".v#{vars.migrTargVer.toVarName}")
%>
                // substituting in <%=vars.javaPackage%>: ".v<%=ver2.toVarName%>" with ".v<%=vars.migrTargVer.toVarName%>"
            <%=vars.jpMigr%>.<%=migrClass(vars.baseName, vars.srcVer, vars.migrTargVer)%>.getInstance().migrate(<% break if vars.srcVer <= vars.switchTargVer
   end # migration steps loop %>

                <%=vars.srcType%>_InOutable.getInstance().read(in)
            <%= vars.brackets %>;
<% end %>
        }
        else throw new IllegalArgumentException("Unsupported version for the record <%=vars.baseName%>: " + ver);
    }
<%  end
  } # records loop %>
}

