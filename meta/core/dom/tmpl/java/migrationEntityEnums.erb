<%#
    Template for Java POJO migration scenario, includes full migration support for enums too.
%>
package <%=javaPackage%>;

/*
           This class is generated by DataMeta DOM. Do not edit manually!
*/
import java.time.ZonedDateTime;
import org.ebay.datameta.dom.Migrator;
import java.util.stream.Collectors;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toSet;

<%
  srcPackage = javaPackage.gsub(".v#{ver2.toVarName}", ".v#{ver1.toVarName}")
%>
public class <%=javaClassName%> implements Migrator<<%=srcPackage%>.<%=baseName%>, <%=baseName%>> {

    private static final <%=javaClassName%> INSTANCE = new <%=javaClassName%>();

    public static <%=javaClassName%> getInstance() { return INSTANCE; }

    public <%=baseName%> migrate(<%=srcPackage%>.<%=baseName%> src, Object... xtras) {
        final <%=baseName%> result = new <%=baseName%>();
<%
  srcFldKeys = Set.new srcE.fields.keys
  trgFldKeys = Set.new trgE.fields.keys
  added = trgFldKeys - srcFldKeys
  addedReq = added.select{|k| trgE[k].isRequired}
  addedOpt = added.reject{|k| trgE[k].isRequired}
  if addedReq.size > 0
     migrCtx.canAuto = false%>
        !!>/* !!> The following <%=addedReq.size%> required field(s) added to this record:
            !!> <%= addedReq.map{|k| k.to_s}.sort.join(', ') %>
            !!> you must add some value for those here */
<%end

  if addedOpt.size > 0%>
  /*
    The following <%=addedOpt.size%> optional field(s) added to this record:
        <%= addedOpt.map{|k| k.to_s}.sort.join(', ') %>
    no action taken on this.
  */
<%  end

  removed = srcFldKeys - trgFldKeys
  if removed.size > 0%>
    /*
    The following <%=removed.size%> field(s) removed from this record:
    <%= removed.map{|k| k.to_s}.sort.join(', ') %>
    no action taken on this.
    */
<%end
#  _erbout << "/*\ntrgE.fields.keys: #{trgE.fields.keys.inspect}\n*/\n"
  trgE.fields.keys.sort.each { |trgK|
     vars.trgFld = trgE.fields[trgK]
     vars.trgDType = vars.trgFld.dataType
     vars.trgType = vars.trgDType.type
     if vars.trgFld.trgType
         migrCtx.canAuto = false%>
        !!> // field "<%=vars.trgFld.name%>" is a map. Maps currently are not supported on serialization level!!<%
     end
     vars.srcFld = srcE.fields[trgK]
#     _erbout << "//trgFld=#{vars.trgFld}, srcFld=#{vars.srcFld}\n"
     next unless vars.srcFld
     vars.srcType = flipVer(vars.srcFld.dataType.type, ver2, ver1)
     if model1.records[vars.srcType] # DataMeta DOM record type
         fNs, vars.fBase = DataMetaDom.splitNameSpace(vars.trgFld.dataType.type)
         if vars.trgFld.aggr
             case vars.trgFld.aggr
                 when Field::SET
%>        result.<%=setterName(vars.trgFld)%>(src.<%=getterName(vars.trgFld)%>().stream().map(e -> <%=migrClass(vars.fBase, ver1, ver2)%>.getInstance().migrate(e)).collect(toSet()));
<%                 when Field::DEQUE
%>        result.<%=setterName(vars.trgFld)%>(new LinkedList<>(src.<%=getterName(vars.trgFld)%>().stream().map(e -> <%=migrClass(vars.fBase, ver1, ver2)%>.getInstance().migrate(e)).collect(toList())));
<%               when Field::LIST
%>        result.<%=setterName(vars.trgFld)%>(new ArrayList<>(src.<%=getterName(vars.trgFld)%>().stream().map(e -> <%=migrClass(vars.fBase, ver1, ver2)%>.getInstance().migrate(e)).collect(toList())));
<%                 else
                 raise ArgumentError, %<Unsupported aggregation type "#{vars.trgFld.aggr}" on the field "#{trgK}" of the record>
             end
             #result.setEmbeds(new ArrayList<>(src.getEmbeds().stream().map(e -> Migrate_EmbeddedType_v6_to_v7.getInstance().migrate(e)).collect(toList())));
             #result.setIdLessNess(src.getIdLessNess().stream().map(e -> Migrate_IdLess_v6_to_v7.getInstance().migrate(e)).collect(toSet()));
         else
             if vars.srcFld.aggr
                migrCtx.canAuto = false%>
              !!> // field "<%=vars.trgFld.name%>" changed from aggregate to scalar, you need to write up custom code for this.
<%           else%>
        result.<%=setterName(vars.trgFld)%>(<%=migrClass(vars.fBase, ver1, ver2)%>.getInstance().migrate(src.<%=getterName(vars.trgFld)%>()));
<%           end

         end

     elsif model1.enums[vars.srcType] # DataMeta enum type
        unless model2.enums[vars.trgType]
            migrCtx.canAuto = false%>
            !!> // field "<%=vars.trgFld.name%>" turned from an enumerable type to a non-enumerable type. Please handle this manually.!!
<%      end
        fNs, vars.fBase = DataMetaDom.splitNameSpace(vars.trgFld.dataType.type)
        e1 = model1.enums[vars.srcType]
        e2 = model2.enums[vars.trgType]
        if e2.kind_of?(DataMetaDom::Mappings)
            migrCtx.canAuto = false%>
            !! Field "<%=vars.trgFld.name%>" is a mapping. Mappings are not supported on serialization level!!
<%      elsif e2.kind_of?(DataMetaDom::BitSet)
            migrCtx.canAuto = false%>
            !! Field "<%=vars.trgFld.name%>" is a Bit Set. Bit Sets are not supported on serialization level!!
<%        else
          if e2.isEqOrXtOf(e1) == :ne
              migrCtx.canAuto = false%>
              !!> // Irreconcilable changes in the enum field "<%=vars.trgFld.name%>": list of [<%= e1.rawVals * ', ' %>] to [<%=e2.rawVals * ', '%>]. Please handle this manually.!!
<%        else%>
        result.<%=setterName(vars.trgFld)%>(<%=vars.fBase%>.forOrd(src.<%=getterName(vars.trgFld)%>().ordinal()));
<%        end
        end

     else # DataMeta DOM standard type
         vars.srcDType = vars.srcFld.dataType # can go easy on namespaces and such, they don't apply to std types
         vars.srcType = vars.srcDType.type
         case vars.trgType
             when DATETIME
                 if vars.srcType == DATETIME%>
        result.<%=setterName(vars.trgFld)%>(src.<%=getterName(vars.trgFld)%>());
<%               else
                migrCtx.canAuto = false%>
                !!> // Field "<%=vars.trgFld.name%>" changed from <%=vars.srcType%> to <%=vars.trgType%> -- please handle this manually!
<%                end
             when URL%>
        result.<%=setterName(vars.trgFld)%>(src.<%=getterName(vars.trgFld)%>());
<%
             when BOOL%>
        result.<%=setterName(vars.trgFld)%>(src.<%=getterName(vars.trgFld)%>());
<%           when INT
                 if vars.trgFld.aggr%>
        //noinspection Convert2MethodRef
        result.<%=setterName(vars.trgFld)%>(<%=setAggrPrims(vars.trgFld)%>);
<%               else
                     if vars.trgDType.length == vars.srcDType.length%>
        result.<%=setterName(vars.trgFld)%>(src.<%=getterName(vars.trgFld)%>());
<%                   else%>
        result.<%=setterName(vars.trgFld)%>(src.<%=getterName(vars.trgFld)%>().<%=primValMethod(vars.trgDType)%>());
<%                   end
                end
             when FLOAT
                 if vars.trgFld.aggr%>
        //noinspection Convert2MethodRef
        result.<%=setterName(vars.trgFld)%>(<%=setAggrPrims(vars.trgFld)%>);
<%                 else
                       if vars.trgDType.length == vars.srcDType.length%>
        result.<%=setterName(vars.trgFld)%>(src.<%=getterName(vars.trgFld)%>());
<%                     else%>
        result.<%=setterName(vars.trgFld)%>(src.<%=getterName(vars.trgFld)%>().<%=primValMethod(vars.trgDType)%>());
<%                     end
                 end
             when NUMERIC%>
        result.<%=setterName(vars.trgFld)%>(src.<%=getterName(vars.trgFld)%>());
<%           when STRING, CHAR%>
        result.<%=setterName(vars.trgFld)%>(src.<%=getterName(vars.trgFld)%>());
<%             else
                migrCtx.canAuto = false%>
              !!> // Unsupported data type "<%=vars.trgType%>" on the field "<%=vars.trgFld.name%>". !!
<%       end
     end
  }
%>
        return result;
    }
}
